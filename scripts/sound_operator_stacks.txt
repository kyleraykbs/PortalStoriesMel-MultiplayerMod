"start_stacks"
{
	"start_default"
	{
		"stop_entries"
		{
			"operator" "sys_stop_entries"
		}
	}
	"start_test_random"
	{
		"random_float"
		{
			"operator" "math_random"
			"input_min" "0.0"
			"input_max" "1.0"
		}
	}

	"start_test"
	{

		// "get_elapsed"
		// {
			// "operator" "get_entry_time"
		// }

// 		"play_entry"
// 		{
// 			"operator" "sys_start_entry"
// 			"input_start" "1"	
// 			"entry_name" "xray.beep"	
// 		}
		"stop_entries"
		{
			"operator" "sys_stop_entries"
		}
		"block_entries"
		{
			"operator" "sys_block_entries"
			"input_active" "1.0"	
			"input_duration" "2.0"
			"match_substring" "false"
			"match_entry" "xray.beep"
			// "match_sound" "npc\dog\dog_idlemode_loop1.wav"
			"match_channel" "false"
			"match_entity" "false"
		}
		"delay_output"
		{
			"operator" "sys_output"
			"input_float" "0.0"
			"output" "delay"
		}
	}
	"start_global_bpm_quantize"
	{
		"sys_time"
		{
			"operator" "get_sys_time"
		}
		"bpm"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "60"
			"input2" "120"	
		}
		"beats"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@bpm.output"
			"input2" "1"	
		}
 		"time_mod"
		{
			"operator" "math_float"
			"apply" "mod"
			"input1" "@sys_time.output_client_time"
			"input2" "@beats.output"
		}
 		"negative_delay"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "@time_mod.output"
			"input2" "-1.0"
		}
		"delay_output"
		{
			"operator" "sys_output"
			"input_float" "@negative_delay.output"
			"output" "delay"
		}
	}
	"start_sync_to_entry"
	{
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		"duration_div"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time.output_sound_duration"
			"input2" "4"	
		}
 		"time_mod"
		{
			"operator" "math_float"
			"apply" "mod"
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "@duration_div.output"
		}
 		"div_mult"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "0.0"
			"input2" "@duration_div.output"
		}
 		"add_offset"
		{
			"operator" "math_float"
			"apply" "add"
			"input1" "@time_mod.output"
			"input2" "@div_mult.output"
		}
 		"negative_delay"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "@add_offset.output"
			"input2" "-1.0"
		}
		"delay_output"
		{
			"operator" "sys_output"
			"input_float" "@negative_delay.output"
			"output" "delay"
		}
	}
	"start_delay_sync_to_entry"
	{
		"import_stack" "start_sync_to_entry"
 		"negative_delay"
		{
			"apply" "sub"
			"input1" "@duration_div.output"
			"input2" "@time_mod.output"
		}

	}

	"P2_coop_robot_start"
	{
		"stop_footsteps"
		{
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000" //A sound will not stop itself from playing.
			"match_entity" "false"	
			"match_substring" "true"	
		}
	}
	
	"P2_portalgun_start"
	{
		"stop_gun"
		{
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000" //A sound will not stop itself from playing.
			"match_entity" "false"	
			"match_substring" "true"	
		}
	}
	
	"P2_poly_limiting_start" //Generic poly limiter.  Override values to make usable.
	{
		"limit_sound"
		{
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000" //A sound will not stop itself from playing.
			"match_entity" "false"	
			"match_substring" "true"
			"match_entry" "NONE"		
		}
		
		"limit_robot_sounds"
		{
			"operator" "sys_stop_entries"
			"input_max_entries" "23.000000" //A sound will not stop itself from playing.
			"match_entity" "false"	
			"match_substring" "true"
			"match_entry" "Robot"		
		}
		
		//Console hacks begin here.
		
		
		"sys_get_platform" //should be for X360/PS3, only use PC for testing.
		{
			"operator" "sys_platform"
			//"pc" "true" //IF THIS IS UNCOMMENTED CHANGE IT!!!  SERIOUSLY!!!
			"x360" "true"
			"ps3" "true"
		}
		
		"limit_robot_sounds_ps3"
		{
			"operator" "sys_stop_entries"
			"input_execute" "@sys_get_platform.output"
			"input_max_entries" "9.000000" //I hate myself.
			"match_entity" "false"	
			"match_substring" "true"
			"match_entry" "Robot"		
		}
		
		"ps3_num_voices_compare"
		{
			"operator" "math_float"
			"apply" "greater_than_or_equal"	
			"input1" "@limit_robot_sounds_ps3.output_entries_matching" // This is the percentage chance to play a null
			"input2" "10.0" //match the max number of played sounds ( = input_max_entries + 1 )
		}
		
		"block_robot_entries_ps3"  //helps with disc I/O: Blocks sound requests of robots once a max number of robots exist
		{
			"operator" "sys_block_entries"
			//"input_execute" "0.0"
			"input_execute" "@ps3_num_voices_compare.output"
			"input_active" "1.0"	
			"input_duration" "0.25" //in seconds, you can use "@get_random.output" for a random blocking period
			"match_substring" "true"
			"match_entry" "Robot" //The sound entry to use
			"match_channel" "false"
			"match_entity" "false"
		}
		
		"limit_sound_ps3"
		{
			"operator" "sys_stop_entries"
			"input_execute" "0.0"
			//"input_execute" "@sys_get_platform.output"
			"input_max_entries" "0.000000" //A sound will not stop itself from playing.
			"match_entity" "false"	
			"match_substring" "true"
			"match_entry" "NONE"		
		}
		
		"block_entries_ps3"
		{
			"operator" "sys_block_entries"
			"input_execute" "0.0"
			//"input_execute" "@sys_get_platform.output"
			"input_active" "1.0"	
			"input_duration" "5.0" //in seconds, you can use "@get_random.output" for a random blocking period
			"match_substring" "false"
			"match_entry" "NONE" //The sound entry to use
			"match_channel" "false"
			"match_entity" "false"
		}
		
	}
	
	"P2_exclusion_time_blocker_start" //Generic exclusion time.  Override values to make usable.
	{
		"get_random"
		{
			"operator" "math_random"
			"input_execute" "0.0"
			"input_min" "0.0"
			"input_max" "1.0"		
		}
		
		"block_entries"
		{
			"operator" "sys_block_entries"
			"input_active" "1.0"	
			"input_duration" "0.1" //in seconds, you can use "@get_random.output" for a random blocking period
			"match_substring" "false"
			"match_entry" "NONE" //The sound entry to use
			// "match_sound" "npc\dog\dog_idlemode_loop1.wav"
			"match_channel" "false"
			"match_entity" "false"
		}
	}
	
	"P2_exclusion_time_and_poly_limiting_start" //Combines exclusion time and poly limiting
	{
		"import_stack" "P2_exclusion_time_blocker_start"
		"import_stack" "P2_poly_limiting_start"		
	}
	
	"P2_null_start" //replaces null.wav
	{
		"get_random_null"
		{
			"operator" "math_random"
			"input_execute" "0.0"
			"input_min" "0.0"
			"input_max" "1.0"		
		}
		
		"percent_null"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "0.60" // This is the percentage chance to play a null
			"input2" "@get_random_null.output" 
		}

		"block_start"
		{	
			"input_execute" "1.0"
			//"input_execute" "@percent_null.output"
			"operator" "sys_output"
			"input_float" "1"
			"output" "block_start"
		}
	}
	
	"P2_null_player_start" //Play an entry other than the called one!
	{
		"play_entry"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"1.0"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}

		"block_start"
		{	
			"input_execute" "1.0"
			"operator" "sys_output"
			"input_float" "1"
			"output" "block_start"
		}	
	
	}


////////////////////////////////////////////////////////////////////////////////////////////
//
// dialog start stacks
//
////////////////////////////////////////////////////////////////////////////////////////////

	"P2_glados_start" // default start stack for glados v.o.
	{
		"set_mixlayer_vol_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "announcerVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_cave"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "caveVO"
			"field" "volume"
			"input" "1.0"
		}
	}
	"P2_glados_start_mute" // default start stack for glados v.o.
	{
		"set_mixlayer_mute_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "mute"
			"input" "0.0"
		}
		"set_mixlayer_mute_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "announcerVO"
			"field" "mute"
			"input" "0.0"
		}
		"set_mixlayer_mute_cave"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "caveVO"
			"field" "mute"
			"input" "0.0"
		}
	}
	"P2_wheatley_start" // default start stack for wheatley v.o.
	{
		"set_mixlayer_vol_glados"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "wheatleyVOLayer"
			"mixgroup" "gladosVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "wheatleyVOLayer"
			"mixgroup" "announcerVO"
			"field" "volume"
			"input" "1.0"
		}
	}
	"P2_announcer_start" // default start stack for announcer v.o.
	{
		"set_mixlayer_vol_glados"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "announcerVOLayer"
			"mixgroup" "gladosVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "announcerVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "volume"
			"input" "1.0"
		}
	}
	

}


////////////////////////////////////////////////////////////////////////////////////////////
//
// update stacks
//
////////////////////////////////////////////////////////////////////////////////////////////
"update_stacks"
{

////////////////////////////////////////////////////////////////////////////////////////////
//
// TEST STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////

	"update_test1"
	{

		"test1_value1"
		{
			"operator" "math_float"
			"apply" "add"	
			"input1" "8"
			"input2" "9"
		}
		"test1_value1"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "0"
			"input2" "1"
		}
		"test1_value2"
		{
			"operator" "math_float"
			"apply" "add"	
			"input1" "@test1_value1.output"
			"input2" "1"
		}
	}
	"update_test2"
	{
		"test2_value1"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "8"
			"input2" "9"
		}
		"test2_value1"
		{
			"apply" "add"	
			"input1" "6"
			"input2" "7"
		}
		"test2_value2"
		{
			"operator" "math_float"
			"apply" "add"	
			"input1" "@test2_value1.output"
			"input2" "1"
		}
	}
	"update_test3"
	{
		"import_stack" "update_test1"
		"import_stack" "update_test2"
		"test2_value1"
		{
			"apply" "add"	
			"input1" "2"
			"input2" "3"
		}
	}
	"update_test4"
	{
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		"duration_div"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time.output_sound_duration"
			"input2" "4"	
		}
		"time_div"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "@duration_div.output"	
		}
		"time_mod"
		{
			"operator" "math_float"
			"apply" "mod"	
			"input1" "@time_div.output"
			"input2" "1"	
		}
		"time_step"
		{
			"operator" "math_float"
			"apply" "sub"	
			"input1" "@time_div.output"
			"input2" "@time_mod.output"
		}
		"step_delta"
		{
			"operator" "math_delta"
			"input" "@time_step.output"	
		}
		"delta_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@step_delta.output"
			"input2" "0.1"
		}
		
		"play_entry"
		{
			"operator" "sys_start_entry"
			"input_start" "@delta_trigger.output"
			"entry_name" "xray.beep"	
		}

		"speaker_volume"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1"
			"input2" "1"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"
			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "0.0"
			"right_rear"   "0.0"	
			
			"input2[*]" "@speaker_volume.output"		
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}

	"update_remap_tests"
	{

		"remap_norm"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".7"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_norm_rev1"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".7"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_norm_rev2"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".7"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "1.0"
			"input_map_max" "0.0"
		}
		"remap_norm_rev3"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".7"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "1.0"
			"input_map_max" "0.0"
		}
		"remap_less_than_min"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_greater_than_max"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "2"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_less_than_min_clamp"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"clamp_range" "true"	
		}
		"remap_greater_than_max_clamp"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "2"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"clamp_range" "true"	
		}

		"remap_equal_equal_min_max"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "1"
			"input_min" "1"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_equal_equal_min_max_default_min"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "1"
			"input_min" "1"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"
		}

		"remap_less_than_equal_min_max"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".5"
			"input_min" "1"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_greater_than_equal_min_max"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "1.5"
			"input_min" "1"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_greater_than_range"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "1.5"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_less_than_range"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "0.5"
			"input_min" "1.0"
			"input_max" "2.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}

		"remap_norm_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" ".7"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_less_than_min_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_greater_than_max_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "2"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
		}
		"remap_less_than_min_clamp_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"clamp_range" "true"	
		}
		"remap_greater_than_max_clamp_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "2"
			"input_min" "1"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"clamp_range" "true"	
		}

		"big_remap_norm"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "70"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_less_than_min"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_greater_than_max"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "200"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_less_than_min_clamp"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-1"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
			"clamp_range" "true"	
		}
		"big_remap_greater_than_max_clamp"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "200"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
			"clamp_range" "true"	
		}

		"big_remap_greater_than_range"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "150"
			"input_min" "0"
			"input_max" "100"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_less_than_range"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "50"
			"input_min" "100.0"
			"input_max" "200.0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}

		"big_remap_norm_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "70"
			"input_min" "100"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_less_than_min_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-100"
			"input_min" "100"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_greater_than_max_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "200"
			"input_min" "100"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
		}
		"big_remap_less_than_min_clamp_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "-100"
			"input_min" "100"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
			"clamp_range" "true"	
		}
		"big_remap_greater_than_max_clamp_rev"
		{
			"execute_once" "true"
			"operator" "math_remap_float"
			"input" "200"
			"input_min" "100"
			"input_max" "0"
			"input_map_min" "0.0"
			"input_map_max" "100.0"
			"clamp_range" "true"	
		}


	}

	"update_remap_test"
	{

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		// NOTE: uses player data, ie: SS
		// SS Self-contained, returns closest distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		"remap_distance"
		{
			"operator" "math_remap_float"
			"input" "@source_distance.output"
			"input_min" "300"
			"input_max" "1000"
			"input_map_min" "0.80"
			"input_map_max" "1.2"
		}
		"invert_remap"
		{
			"operator" "math_float"
// 			"apply" "sub"
			"apply" "mult"
			"input1" "1.0"
			"input2" "@remap_distance.output"
		}

		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@remap_distance.output"	
		}

	
		/////////////////////
		// SPEAKERS

		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@invert_remap.output"
			// "input2[*]"	   "@facing.output"
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_volume.output"
			"output" "speakers"
		}
	}


	"update_stop_at_time"
	{
		"usat_elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"usat_stop_time"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@usat_elapsed_time.output_entry_elapsed"
			"input2" "1.0"
		}
		"usat_stop_entry"
		{
			"input_execute" "@usat_stop_time.output"
			"operator" "sys_stop_entries"
			"stop_this_entry" "true"	
		}
	}

	"update_trigger_layer_til_time"
	{
		"utltt_elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"utltt_trigger_time"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@utltt_elapsed_time.output_sound_elapsed"
			"input2" "1.0"
		}
		"utltt_output_mixlayer_trigger"
		{
			"operator" "sys_output"
			"input_float" "@utltt_trigger_time.output"
			"output" "mixlayer_trigger"
		}

	}

	"update_stop_at_distance"
	{
		// this will use the standard "source_distance" operator exists
		"usad_stop_dist"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "0.0"
			"input2" "1.0"
		}
		"usad_stop_entry"
		{
			"operator" "sys_stop_entries"
			"input_execute" "@usad_stop_dist.output"
			"stop_this_entry" "true"	
		}
	}
	
////////////////////////////////////////////////////////////////////////////////////////////
//
// TRIGGER STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////
	"update_music_div_trigger"
	{
		"elapsed_time_div"
		{
			"operator" "get_entry_time"
		}
		"duration_div"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time_div.output_sound_duration"
			"input2" "4"	
		}
		"time_div"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time_div.output_sound_elapsed"
			"input2" "@duration_div.output"	
		}
		"time_mod"
		{
			"operator" "math_float"
			"apply" "mod"	
			"input1" "@time_div.output"
			"input2" "1"	
		}
		"time_step"
		{
			"operator" "math_float"
			"apply" "sub"	
			"input1" "@time_div.output"
			"input2" "@time_mod.output"
		}
		"step_delta"
		{
			"operator" "math_delta"
			"input" "@time_step.output"	
		}
		"delta_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@step_delta.output"
			"input2" "0.1"
		}
		
		"play_entry"
		{
			"operator" "sys_start_entry"
			"input_start" "@delta_trigger.output"
			"entry_name" "xray.beep"	
		}
	}

	"update_looping_triggers"
	{
		"elapsed_time_div"
		{
			"operator" "get_entry_time"
		}
		///////////// x1
 		"duration_div_x1"
 		{
 			"operator" "math_float"
 			"apply" "div"	
 			"input1" "@elapsed_time_div.output_sound_duration"
 			"input2" "4"	
 		}
		"time_div_x1"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time_div.output_entry_elapsed"
			"input2" "@duration_div_x1.output"	
		}
		"time_mod_x1"
		{
			"operator" "math_float"
			"apply" "mod"	
			"input1" "@time_div_x1.output"
			"input2" "1"	
		}
		"time_step_x1"
		{
			"operator" "math_float"
			"apply" "sub"	
			"input1" "@time_div_x1.output"
			"input2" "@time_mod_x1.output"
		}
		"step_delta_x1"
		{
			"operator" "math_delta"
			"input" "@time_step_x1.output"	
		}
		"delta_trigger_x1"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@step_delta_x1.output"
			"input2" "0.1"
		}
		
		"play_entry_x1"
		{
			"operator" "sys_start_entry"
			"input_start" "@delta_trigger_x1.output"
			"entry_name" "xray.beep"	
		}

		///////////// x2
 		"duration_div_x2"
 		{
 			"operator" "math_float"
 			"apply" "div"	
 			"input1" "@elapsed_time_div.output_sound_duration"
 			"input2" "4"	
 		}
		"time_div_x2"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@elapsed_time_div.output_entry_elapsed"
			"input2" "@duration_div_x2.output"	
		}
		"time_mod_x2"
		{
			"operator" "math_float"
			"apply" "mod"	
			"input1" "@time_div_x2.output"
			"input2" "1"	
		}
		"time_step_x2"
		{
			"operator" "math_float"
			"apply" "sub"	
			"input1" "@time_div_x2.output"
			"input2" "@time_mod_x2.output"
		}
		"step_delta_x2"
		{
			"operator" "math_delta"
			"input" "@time_step_x2.output"	
		}
		"delta_trigger_x2"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@step_delta_x2.output"
			"input2" "0.1"
		}
		
		"play_entry_x2"
		{
			"operator" "sys_start_entry"
			"input_start" "@delta_trigger_x2.output"
			"entry_name" "xray.beep"	
		}
	}


////////////////////////////////////////////////////////////////////////////////////////////
//
// MUSIC STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////
	"update_music_stereo"
	{
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"
			"input_float" "1.0"
			"output" "save_restore"
		}
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "Music"
		}
		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_musicvolume_convar"
		{
			"operator" "get_convar"
			"convar" "snd_musicvolume"
		}
		"dashboard"
		{
			"operator" "get_dashboard"
		}
		"convar_total"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_musicvolume_convar.output"
			"input2" "@snd_gain_convar.output"
		}
		"dashboard_total"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@convar_total.output"
			"input2" "@dashboard.output"
		}
		"volume_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}
		"volume_fade_initial"
		{
			"input_execute" "0"
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_initial"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_initial.output"
		}
		"volume_lfo_time_scale"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.0"	
		}
		"volume_lfo"
		{
			"operator" "math_func1"
			"function" "cos"
			"normalize_trig" "true"	
			"input1" "@volume_lfo_time_scale.output"
		}
		"volume_lfo_scale"
		{
			"operator" "math_float"
			"apply"	"invert_scale"
			"input1" "@volume_lfo.output"
			"input2" "0.0"
		}

		"volume_fade_out"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_stop_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_fadeout"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_out.output"
		}
		"volume_apply_fade_in"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_fade_in.output"
			"input2" "@dashboard_total.output"
		}
		"volume_apply_fade_initial"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_invert_initial.output"
			"input2" "@volume_apply_fade_in.output"
		}
		"volume_apply_lfo"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_initial.output"
			"input2" "@volume_lfo_scale.output"
		}
		"volume_apply_fade_out"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_lfo.output"
			"input2" "@volume_invert_fadeout.output"
		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_fade_out.output"	
		}
		"volume_apply_adjust"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_mixer.output"	
		}
		"speaker_volume"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@source_info.output_volume"
			"input2" "@volume_apply_adjust.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"
			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "0.8"
			"right_rear"   "0.8"	
			
			"input2[*]" "@speaker_volume.output"		
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
		"output_mixlayer_trigger"
		{
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}
		"stoptime_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@volume_invert_fadeout.output"
			"input2" "0.0" 
		}
		"stop_hold_output"
		{
			"operator" "sys_output"
			"output"   "stop_hold"
			"input_float" "@stoptime_elapsed_trigger.output"	
		}
	}	

	"update_music_spatial"
	{
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"
			"input_float" "1.0"
			"output" "save_restore"
		}

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		"elapsed_time"
		{
			"operator" "get_entry_time"
		}

		"position_array"
		{
			"operator" "util_pos_vec8"
				
			"input_entry_count" "1"
			"input_index" "0"	
			"input_position_0" "@source_info.output_position"

		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@position_array.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "Music"
		}

		// NOTE: uses player data, ie: SS, return least occluded value
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position"   "@position_array.output_position"
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}
		"snd_musicvolume_convar"
		{
			"operator" "get_convar"
			"convar" "snd_musicvolume"
		}

		"dashboard"
		{
			"operator" "get_dashboard"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME

		// NOTE: distance has precalculated minimum distance of the ss players	

		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}

		"volume_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "@source_info.output_volume"
		}

		"volume_clamp_fade_in"
		{
			"operator" "math_float"
			"apply"	"min"
			"input1" "@volume_fade_in.output"
			"input2" "1.0"
		}
		"volume_fade_initial"
		{
			"input_execute" "0"
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_initial"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_initial.output"
		}
		"volume_apply_fade_initial"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_invert_initial.output"
			"input2" "@volume_clamp_fade_in.output"
		}

		"volume_fade_out"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_stop_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_fadeout"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_out.output"
		}

		"volume_apply_fade_out"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_initial.output"
			"input2" "@volume_invert_fadeout.output"
		}

		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_out.output"
			"input2" "@volume_falloff.output"
		}

		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}

		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}

		"volume_apply_musicvolume_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_musicvolume_convar.output"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_musicvolume_convar.output"
			"input2" "@occlusion.output"
		}

		"volume_apply_dashboard"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@volume_apply_occlusion.output"
			"input2" "@dashboard.output"
		}


		// set dsp just to be sure
		"dsp_output"
		{
			"operator" "sys_output"
			// "input_float" "@dsp_apply_distant.output"
			"input_float" "0"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_rear_stereo_scale" "1.0"	
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"   "@position_array.output_position"
		}
	
		"speakers_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_dashboard.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2" "@speakers_volume.output"
		
		}

		"speakers_multi_origin"
		{
			"operator"    "iterate_merge_speakers"

			"input_max_iterations" "@position_array.output_max_index"
            "iterate_operator" "position_array"
			"input" "@speakers_limit.output"

		}
		// connecting output after operator has been created
		"position_array"
		{
			"input_index" "@speakers_multi_origin.output_index"	
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_multi_origin.output"
			"output" "speakers"
		}

		// stop deletion until after fadeout
		"stoptime_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@volume_invert_fadeout.output"
			"input2" "0.0" 
		}
		"stop_hold_output"
		{
			"operator" "sys_output"
			"output"   "stop_hold"
			"input_float" "@stoptime_elapsed_trigger.output"	
		}
	}	



	"update_music_spatial_stop_dist"
	{
		"import_stack" 	"update_music_spatial"

		"import_stack" 	"update_stop_at_distance"
		"usad_stop_dist"
		{
			"input1" "@source_distance.output"
			"input2" "1.0"  // distance beyond which to stop
		}
	}

	"update_music_spatial_looping_triggers"
	{
		"import_stack" 	"update_music_spatial"
		"import_stack" "update_looping_triggers"
	}

	"update_music_stereo_trigger"
	{
		"import_stack" 	"update_music_stereo"
		"import_stack" "update_music_div_trigger"
	}


	"p2_update_music_play_tbeam"
	{
		"tb_mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "testTBin"
		}
// 		"print_tb_mixer"
// 		{
// 			"operator" "util_print_float"
// 			"input" "@tb_mixer.output_volume"	
// 		}
		"tb_delta"
		{
			"operator" "math_delta"
			"input" "@tb_mixer.output_volume"	
		}
		"tb_mixer_zero"
		{
			"operator" "math_float"
			"apply" "less_than_or_equal"	
			"input1" "@tb_mixer.output_volume"
			"input2" "0.0"
		}
		"tb_start_trigger"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@tb_delta.output"
			"input2" "0.0"
		}
		"tb_start_trigger_test"
		{
			"operator" "math_float"
			"apply" "min"	
			"input1" "@tb_start_trigger.output"
			"input2" "@tb_mixer_zero.output"
		}
// 		"print_tb_delta"
// 		{
// 			"operator" "util_print_float"
// 			"input" "@tb_delta.output"	
// 		}

// 		"print_start_trigger"
// 		{
// 			"input_execute" "@tb_start_trigger.output"
// 			"operator" "util_print_float"
// 			"input" "@tb_start_trigger_test.output"	
// 		}
		"tb_stop_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@tb_mixer.output_volume"
			"input2" "0.0"
		}
		
		"play_entry"
		{
			"execute_once" "false"
			"operator" "sys_start_entry"
			"input_start" "1"	
			"input_execute" "@tb_start_trigger_test.output"	
			"entry_name" "Default.Null"
		}	
		"stop_entry"
		{
			"input_execute" "@tb_stop_trigger.output"	
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000"
			"match_entity" "false"	
			"match_substring" "false"
			"match_entry" "Default.Null"
		}
	}


	"p2_update_music_play_gel"
	{
		"gel_elapsed_time"
		{
			"operator" "get_entry_time"
		}

		"bounce_view_info"
		{
			"operator" "game_view_info"
		}
		"gel_mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "testGelBounce"
		}
		"gel_delta"
		{
			"operator" "math_delta"
			"input" "@gel_mixer.output_volume"	
		}
// 		"gel_delta_test"
// 		{
// 			"operator" "math_float"
// 			"apply" "less_than"	
// 			"input1" "@gel_delta.output"
// 			"input2" "0.0"
// 		}
// 		"print_delta"
// 		{
// 			"input_execute" "@gel_delta_test.output"
// 			"operator" "util_print_float"
// 			"input" "@gel_delta.output"	
// 		}
		"gel_mixer_zero"
		{
			"operator" "math_float"
			"apply" "less_than_or_equal"	
			"input1" "@gel_mixer.output_volume"
			"input2" "0.0"
		}
		"gel_start_trigger"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@gel_delta.output"
			"input2" "0.0"
		}
		"gel_start_trigger_test"
		{
			"operator" "math_float"
			"apply" "min"	
			"input1" "@gel_start_trigger.output"
			"input2" "@gel_mixer_zero.output"
		}

// 		"gel_start_trigger"
// 		{
// 			"operator" "math_float"
// 			"apply" "less_than"	
// 			"input1" "@gel_delta.output"
// 			"input2" "0.0"
// 		}
		"gel_stop_trigger"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@bounce_view_info.output_velocity_vector_z"
			"input2" "1.0"
		}
		"gel_test_stopped"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@gel_elapsed_time.output_stop_elapsed"
			"input2" "0.0"
		}
// 		"print_gel_test_stopped"
// 		{
// 			"input_execute" "@gel_delta_test.output"
// 			"operator" "util_print_float"
// 			"input" "@gel_test_stopped.output"
// 		}
// 		"print_gel_test_start_trigger"
// 		{
// 			"input_execute" "@gel_delta_test.output"
// 			"operator" "util_print_float"
// 			"input" "@gel_start_trigger.output"
// 		}
// 		"print_gel_test_stop_trigger"
// 		{
// 			"input_execute" "@gel_delta_test.output"
// 			"operator" "util_print_float"
// 			"input" "@gel_stop_trigger.output"
// 		}
		"gel_play_entry"
		{
			"execute_once" "false"
			"operator" "sys_start_entry"
			"input_start" "@gel_test_stopped.output"	
			"input_execute" "@gel_start_trigger_test.output"	
			"entry_name" "Default.Null"
		}	
		"gel_stop_entry"
		{
			"input_execute" "@gel_stop_trigger.output"	
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000"
			"match_entity" "false"	
			"match_substring" "false"
			"match_entry" "Default.Null"
		}
	}


	"p2_update_music_play_speed_gel"
	{
		"speed_view_info"
		{
			"operator" "game_view_info"
		}

		"speed_velocity_fabs_xy"
		{
			"operator" "math_func1"
			"function" "fabs"
			"input1" "@speed_view_info.output_velocity_xy"
		}	

		"speed_velocity_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@speed_velocity_fabs_xy.output"
			"input2" "12"
		}
		"speed_delta"
		{
			"operator" "math_delta"
			"input" "@speed_velocity_trigger.output"	
		}

		"speed_start_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@speed_delta.output"
			"input2" "0"
		}

		"speed_stop_trigger"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@speed_delta.output"
			"input2" "0"
		}

		"speed_play_entry"
		{
			"execute_once" "false"
			"operator" "sys_start_entry"
			"input_start" "1"	
			"input_execute" "@speed_start_trigger.output"	
			"entry_name" "Default.Null"
		}	
		"speed_stop_entry"
		{
			"input_execute" "@speed_stop_trigger.output"	
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000"
			"match_entity" "false"	
			"match_substring" "false"
			"match_entry" "Default.Null"
		}
	}


	"p2_update_music_stereo_bounce"
	{
		"import_stack" 	"update_music_stereo"
		"game_view_info"
		{
			"operator" "game_view_info"
		}
// 		"volume_bounce"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@game_view_info.output_stop_elapsed"
// 			"input_min" "-80.0"
// 			"input_max" "100.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}

		"abs_velocity_vector_z"
		{
			"operator" "math_func1"
			"function"	"fabs"
			"input1" "@game_view_info.output_velocity_vector_z"
		}
		"volume_bounce"
		{
			"operator" "math_remap_float"
			"input" "@abs_velocity_vector_z.output"
			"input_min" "0.0"
			"input_max" "100.0"
			"input_map_min" "0.1"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_apply_adjust"
		{
			"input1" "@volume_bounce.output"
		}

	}

	"p2_update_music_spatial_portals"
	{
		"import_stack" 	"update_music_spatial"
		
		// 	set up so it iterates over portalized sounds
		"speakers_multi_origin"
		{
			"input_max_iterations" "@source_info.output_source_count"
            "iterate_operator" "source_info"
		}
		// connecting output after operator has been created
		"source_info"
		{
			"input_source_index" "@speakers_multi_origin.output_index"	
		}
		// turn off position array indexing 
		"position_array"
		{
			"input_index" "0"	
		}
	}
	
////////////////////////////////////////////////////////////////////////////////////////////
//
// STANDARD STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////
	"update_simple_quad"
	{
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"	
			"input_float" "1.0"
			"output" "save_restore"
		}
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}
		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@snd_gain_convar.output"
		}
		"speaker_volume"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1"
			"input2" "@volume_apply_mixer.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"
			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2[*]" "@speaker_volume.output"		
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}
	}	

	"update_default"
	{
		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		// NOTE: uses player data, ie: SS, return least occluded value
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"	
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME
			
		// NOTE: distance has precalculated minimum distance of the ss players			
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@source_info.output_volume"
			"input2" "@volume_falloff.output"
		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_test_convar.output"
			"input2" "@occlusion.output"
		}
		// this calculates the loudest volume of the ss clients
		// NOT NEEDED ALL SS OPS SELF-CONTAINGED
		// "volume_acc_ss_max"
		// {
			// "operator" "op_accumulate_ss_float"
			// "input" "volume_apply_occlusion.output"
			// "iterate_operator" "occlusion"
		// }	

		// shouldn't this be volume level?
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}
		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distant"
		{
			"operator" "math_float"
			"apply"	      "mult"
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"			
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distant.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_occlusion.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}	

	"p2_update_default"
	{
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"
			"input_float" "1.0"
			"output" "save_restore"
		}
		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		"elapsed_time"
		{
			"operator" "get_entry_time"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		// NOTE: uses player data, ie: SS, return least occluded value
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"	
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME

		// NOTE: distance has precalculated minimum distance of the ss players	
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		
		"volume_get_random" //use for random volume if needed
		{
			"operator" "math_random"
			"execute_once" "true"
			"input_execute" "0.0"
			"input_min" "0.15" //low value here
			"input_max" "0.55"	//high value here.	
		}
		
		"volume_mult"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input2" "@source_info.output_volume"
			"input1" "1.0"
		}

		"volume_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}
		"volume_fade_out"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_stop_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_fadeout"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_out.output"
		}
		"volume_apply_fade_in"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_fade_in.output"
			"input2" "@volume_mult.output"
		}
		"volume_apply_fade_out"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_in.output"
			"input2" "@volume_invert_fadeout.output"
		}

		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_out.output"
			"input2" "@volume_falloff.output"
		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_test_convar.output"
			"input2" "@occlusion.output"
		}
		// this calculates the loudest volume of the ss clients
		// NOT NEEDED ALL SS OPS SELF-CONTAINGED
		// "volume_acc_ss_max"
		// {
			// "operator" "op_accumulate_ss_float"
			// "input" "volume_apply_occlusion.output"
			// "iterate_operator" "occlusion"
		// }	

		"stoptime_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@volume_invert_fadeout.output"
			"input2" "0.0" 
		}
		"stop_hold_output"
		{
			"operator" "sys_output"
			"output"   "stop_hold"
			"input_float" "@stoptime_elapsed_trigger.output"	
		}

		///////////////////
		// PITCH
		
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distant"
		{
			"operator" "math_float"
			"apply"	      "mult"
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"			
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distant.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_occlusion.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}
		"speakers_multi_origin"
		{
			"operator"    "iterate_merge_speakers"

			"input_max_iterations" "@source_info.output_source_count"
            "iterate_operator" "source_info"
			"input" "@speakers_limit.output"

		}
		// connecting output after operator has been created
		"source_info"
		{
			"input_source_index" "@speakers_multi_origin.output_index"	
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_multi_origin.output"
			"output" "speakers"
		}
	}	

	"p2_offset_start_update"
	{
		"import_stack" "p2_update_default"
		
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"time_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
		
		"time_elapsed_trigger_2"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
		
		"time_elapsed_trigger_3"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
		
		"time_elapsed_trigger_4"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
		
		"bool_delta" //Check to see if the trigger has been flipped
		{
			"operator" "math_delta"
			"input" "@time_elapsed_trigger.output"	
		}
		
		"bool_delta_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@bool_delta.output"
			"input2" "0.1"
		}
		
		"play_entry"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@bool_delta_trigger.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
		
		"play_entry_2"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@time_elapsed_trigger_2.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
		
		"play_entry_3"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@time_elapsed_trigger_3.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
		
		"play_entry_4"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@time_elapsed_trigger_4.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}	
	}

	"p2_offset_start_update_random"
	{
		"import_stack" "p2_update_default"
		
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"delay_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
			
		"random_play"
		{
			"operator" "math_random"
			"execute_once" "true"
			"input_execute" "0.0"
			"input_min" "0.0"
			"input_max" "1.0"		
		}	
	
		"percent_fire"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "0.60" // This is the percentage chance to play a sound
			"input2" "@random_play.output" 
		}

		"do_we_fire"
		{
			"operator" "math_float"
			"apply"	"min"
			"input1" "@percent_fire.output"
			"input2" "@delay_trigger.output"
		}
		
		"triggered_sound"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@do_we_fire.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
	}
	
	"p2_offset_start_level_based"
	{
		"import_stack" "p2_update_default"
		
		"elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"delay_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
		
		"delay_trigger_2"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@elapsed_time.output_sound_elapsed"
			"input2" "0.1" //Elapsed time in seconds goes here.
		}
			
		"level_specific_check"
		{
			"input_execute" "0.0" //enable map checking here
			"operator" "get_map_name"
			"map_name" "p2_empty4" //your map name here		
		}	
	
		"get_pos_data"
		{
			"operator" "game_view_info"
		}
		
		"pos_specific_check"
		{
			"operator"	"math_float"
			"apply"	"greater_than_or_equal"
			"input1"	"@get_pos_data.output_position_z" //replace with the param to check against
			"input2"	"0.0" //Replace with val you want to check against		
		}
		
		"level_and_pos_check"
		{
			"operator" "math_float"
			"apply"	"min"
			"input1" "@level_specific_check.output"
			"input2" "@pos_specific_check.output"		
		}

		"do_we_fire"
		{
			"operator" "math_float"
			"apply"	"min"
			"input1" "@level_and_pos_check.output"
			"input2" "@delay_trigger.output"
		}

		"do_we_fire_2"
		{
			"operator" "math_float"
			"apply"	"min"
			"input1" "@level_and_pos_check.output"
			"input2" "@delay_trigger_2.output"
		}
		
		"triggered_sound"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@do_we_fire.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
		
		"triggered_sound_2"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@do_we_fire.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
	}

	"p2_update_start_at_elapsed"
	{
		"usae_elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"sound_duration_mult"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@usae_elapsed_time.output_sound_duration"
			"input2" "2"
		}

		"time_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than_or_equal"	
			"input1" "@usae_elapsed_time.output_sound_elapsed"
			"input2" "@sound_duration_mult.output"
		}
		
		"stop_this"
		{
			"operator" "sys_stop_entries"
			"input_execute"	"@time_elapsed_trigger.output"
			"stop_this_entry" "true"	
		}
		"play_entry"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"@time_elapsed_trigger.output"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
	}

	"p2_update_stop_at_elapsed"
	{
		"usae_elapsed_time"
		{
			"operator" "get_entry_time"
		}
		
		"sound_duration_mult"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@usae_elapsed_time.output_sound_duration"
			"input2" "2"
		}
		"time_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than_or_equal"	
			"input1" "@usae_elapsed_time.output_sound_elapsed"
			"input2" "@sound_duration_mult.output"
		}		
		"stop_this"
		{
			"operator" "sys_stop_entries"
			"input_execute"	"@time_elapsed_trigger.output"
			"stop_this_entry" "true"	
		}
	}
	
	"p2_update_default_pitch_ramp" 
	{
		//This is identical to p2_update_default except for the pitch being ramped based on volume, 
		
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"
			"input_float" "1.0"
			"output" "save_restore"
		}

		
		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		"elapsed_time"
		{
			"operator" "get_entry_time"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		// NOTE: uses player data, ie: SS, return least occluded value
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"	
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME

		// NOTE: distance has precalculated minimum distance of the ss players	
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}

		"volume_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}
		"volume_fade_out"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_stop_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_fadeout"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_out.output"
		}
		"volume_apply_fade_in"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_fade_in.output"
			"input2" "@source_info.output_volume"
		}
		"volume_apply_fade_out"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_in.output"
			"input2" "@volume_invert_fadeout.output"
		}
		
		"volume_fade_initial"
		{
			"input_execute" "0"
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "1.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}		
		"volume_invert_initial"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_initial.output"
		}
		"volume_apply_fade_initial"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_out.output"
			"input2" "@volume_invert_initial.output"
		}
		
		//Level specific volume scalar
		
		"volume_get_map_name"
		{
			"input_execute" "0.0" //enable map checking here
			"operator" "get_map_name"
			"map_name" "p2_empty4" //your map name here
		}	
		
		"volume_invert_map_name"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_get_map_name.output"
		}
		
		"volume_map_name_scalar"
		{
			"operator" "math_remap_float"
			"input" "@volume_invert_map_name.output"
			"input_min" "0.0"
			"input_max" "1.0"
			"input_map_min" "1.0" //This is the map-specific volume scalar, does nothing by default
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}				
		
		"volume_mult"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input2" "@volume_apply_fade_initial.output"
			"input1" "1.0" //change to "@volume_map_name_scalar.output" to use a map specific scalar
		}

		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_mult.output"
			"input2" "@volume_falloff.output"
		}
		
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_test_convar.output"
			"input2" "@occlusion.output"
		}
		// this calculates the loudest volume of the ss clients
		// NOT NEEDED ALL SS OPS SELF-CONTAINGED
		// "volume_acc_ss_max"
		// {
			// "operator" "op_accumulate_ss_float"
			// "input" "volume_apply_occlusion.output"
			// "iterate_operator" "occlusion"
		// }	

		"stoptime_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@volume_invert_fadeout.output"
			"input2" "0.0" 
		}
		"stop_hold_output"
		{
			"operator" "sys_output"
			"output"   "stop_hold"
			"input_float" "@stoptime_elapsed_trigger.output"	
		}

		///////////////////
		// PITCH
		"max_volume_percentage"
		{
			"operator" "math_float"
			"apply" "div"	
			"input1" "@volume_apply_fade_out.output"
			"input2" "@source_info.output_volume"	
		}
		
		"pitch_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@max_volume_percentage.output"
			"input_min" "0.0"
			"input_max" "1.0"
			"input_map_min" "1.0" //Always outputs 1.0 by default
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}
		
		"pitch_random" //Use for random pitch
		{
			"operator" "math_random"
			"execute_once" "true"
			"input_execute" "0.0"
			"input_min" "1.0"
			"input_max" "1.0"		
		}

		"pitch_apply_fade_in"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@pitch_random.output"
			"input2" "@pitch_fade_in.output"
		}
		
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@pitch_apply_fade_in.output"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distant"
		{
			"operator" "math_float"
			"apply"	      "mult"
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"			
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distant.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_occlusion.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}
		"speakers_multi_origin"
		{
			"operator"    "iterate_merge_speakers"

			"input_max_iterations" "@source_info.output_source_count"
            "iterate_operator" "source_info"
			"input" "@speakers_limit.output"

		}
		// connecting output after operator has been created
		"source_info"
		{
			"input_source_index" "@speakers_multi_origin.output_index"	
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_multi_origin.output"
			"output" "speakers"
		}
	}			

	"p2_update_envelope_radius" //This is a wholesale copy of p2_update_default except that we've changed the way falloff works
	{
		"save_restore_output"
		{
			"operator" "sys_output"
			"execute_once" "true"
			"input_float" "1.0"
			"output" "save_restore"
		}


		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		"elapsed_time"
		{
			"operator" "get_entry_time"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		// NOTE: uses player data, ie: SS, return least occluded value
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"	
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME

		// NOTE: distance has precalculated minimum distance of the ss players	
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"volume_mult"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input2" "@source_info.output_volume"
			"input1" "1.0"
		}

		"volume_fade_in"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_entry_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "true"	
		}
		"volume_fade_out"
		{
			"operator" "math_remap_float"
			"input" "@elapsed_time.output_stop_elapsed"
			"input_min" "0.0"
			"input_max" "0.0"
			"input_map_min" "0.0"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
		"volume_invert_fadeout"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@volume_fade_out.output"
		}
		"volume_apply_fade_in"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_fade_in.output"
			"input2" "@volume_mult.output"
		}
		"volume_apply_fade_out"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_in.output"
			"input2" "@volume_invert_fadeout.output"
		}
		
		/////////////////////////////////////////////
		// Massage Falloff
		/////////////////////////////////////////////
		
		"falloff_xover_1" //Use these like variables
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "0.6" //first point goes here
			"input2" "1.0"	//identity, do not change
		}
		
		"falloff_xover_2" //Use these like variables
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "0.45" //second point goes here
			"input2" "1.0"	//identity, do not change
		}
				
		"falloff_leg_1"
		{
			"operator" "math_remap_float"
			"input" "@volume_falloff.output"
			"input_min" "@falloff_xover_1.output" //default 0.6
			"input_max" "1.0"
			"input_map_min" "0.55"
			"input_map_max" "1.0"
			"default_to_max" "false"	
		}
				
		"falloff_leg_2"
		{
			"operator" "math_remap_float"
			"input" "@volume_falloff.output"
			"input_min" "@falloff_xover_2.output" //default 0.45
			"input_max" "@falloff_xover_1.output" //default 0.6
			"input_map_min" "0.4"
			"input_map_max" "@falloff_leg_1.output"
			"default_to_max" "false"	
		}
				
		"falloff_leg_3"
		{
			"operator" "math_remap_float"
			"input" "@volume_falloff.output"
			"input_min" "0.0"
			"input_max" "@falloff_xover_2.output" //default 0.45
			"input_map_min" "0.0"
			"input_map_max" "@falloff_leg_2.output"
			"default_to_max" "true"	
		}

		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_fade_out.output"
			"input2" "@volume_falloff.output"
			//"input2" "@falloff_leg_3.output" //uncomment if you want to use wacky falloffs
		}
		/////////////////////////////////////////////
		
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_test_convar.output"
			"input2" "@occlusion.output"
		}
		// this calculates the loudest volume of the ss clients
		// NOT NEEDED ALL SS OPS SELF-CONTAINGED
		// "volume_acc_ss_max"
		// {
			// "operator" "op_accumulate_ss_float"
			// "input" "volume_apply_occlusion.output"
			// "iterate_operator" "occlusion"
		// }	

		"stoptime_elapsed_trigger"
		{
			"operator" "math_float"
			"apply" "greater_than"	
			"input1" "@volume_invert_fadeout.output"
			"input2" "0.0" 
		}
		"stop_hold_output"
		{
			"operator" "sys_output"
			"output"   "stop_hold"
			"input_float" "@stoptime_elapsed_trigger.output"	
		}

		///////////////////
		// PITCH
		
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distant"
		{
			"operator" "math_float"
			"apply"	      "mult"
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"			
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distant.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_occlusion.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}
		"speakers_multi_origin"
		{
			"operator"    "iterate_merge_speakers"

			"input_max_iterations" "@source_info.output_source_count"
            "iterate_operator" "source_info"
			"input" "@speakers_limit.output"

		}
		// connecting output after operator has been created
		"source_info"
		{
			"input_source_index" "@speakers_multi_origin.output_index"	
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_multi_origin.output"
			"output" "speakers"
		}
	}
	
////////////////////////////////////////////////////////////////////////////////////////////
//
// AMBIENT SOUNDS
//
////////////////////////////////////////////////////////////////////////////////////////////	
	"p2_update_ambient_sound_spatial"	
	{
		"import_stack" 	"p2_update_music_spatial_portals"
	}
	
////////////////////////////////////////////////////////////////////////////////////////////
//
// DIALOG STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////

	"update_dialog"
	{

		///////////////////////
        //  stopping previous lines
		"stop_entries"
		{
			"execute_once" "true"
			"operator" "sys_stop_entries"
			"match_channel" "true"
			"match_entity" "true"	
			"input_max_entries" "0" // doesn't include new one
		}

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}

		////////////////////////
		// tell the mixer we're active
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}

		/////////////////////
		// VOLUME
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@source_info.output_volume"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}

		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_mixer.output"
			"output" "dsp"
		}



		/////////////////////
		// SPEAKERS
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}
		"snd_surround_convar"
		{
			"operator" "get_convar"
			"convar" "snd_surround_speakers"
		}
		"remap_surround_dialog"
		{
			"operator" "math_remap_float"
			"input" "@snd_surround_convar.output"
			"input_min" "2"
			"input_max" "5" //default 0.45
			"input_map_min" "0.0"
//			"input_map_max" "@snd_op_test_convar.output"
			"input_map_max" "0.28"
			"default_to_max" "false"	
		}
		"snd_surround_dialog_invert"
		{
			"operator" "math_float"
			"apply"	"sub"
			"input1" "1.0"
			"input2" "@remap_surround_dialog.output"
		}
		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"

			"input1[*]"	   "@snd_surround_dialog_invert.output"

// 			"left_front"   "1.0"
// 			"right_front"  "1.0"
// 			"center"       "1.0"
			"lfe"          "0.0"	
// 			"left_rear"    "1.0"
// 			"right_rear"   "1.0"
			
			"input2[*]"	   "@volume_apply_snd_gain_convar.output"
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}	

	"update_dialog_spatial"
	{

		///////////////////////
        //  stopping previous lines
		"stop_entries"
		{
			"execute_once" "true"
			"operator" "sys_stop_entries"
			"match_channel" "true"
			"match_entity" "true"	
			"input_max_entries" "0" // doesn't include new one
		}

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			"source"   "entity"
//			"source"   "emitter"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"
//			"input_trace_interval" "0.05"
//			"input_scalar" "0.7"
		}

// 		"print_occlusion"
// 		{
// 			"operator" "util_print_float"
// 			"input" "@occlusion.output"
// 		}
// 		// ramp distance to affect occlusion
// 		"remap_distance_occlusion"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "1000.0"
// 			"input_max" "1500.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"distance_occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@remap_distance_occlusion"
// 		}
// 		"occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@occlusion.output"
// 		}



		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "All"
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}

		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		////////////////////////
		// tell the mixer we're active
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}

			
		// NOTE: distance has precalculated minimum distance of the ss players			
		// ramp distance to affect occlusion
// 		"remap_distance_falloff"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "2500.0"
// 			"input_max" "3000.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"remap_distance_falloff_invert"
// 		{
// 			"operator" "math_float"
// 			"apply"	"sub"
// 			"input1" "1"
// 			"input2" "@remap_distance_falloff.output"
// 		}
		
		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@source_info.output_volume"
			"input2" "@occlusion.output"
//			"input2" "1"
		}
		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_occlusion.output"
			"input2" "@volume_falloff.output"
		}
// 		"volume_apply_distance_falloff"
// 		{
// 			"operator" "math_float"
// 			"apply"	"mult"
// 			"input1" "@volume_apply_falloff.output"
// 			"input2" "@remap_distance_falloff_invert.output"
// 		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
// 		"volume_apply_distance_occlusion"
// 		{
// 			"operator" "math_float"
// 			"apply" "mult"	
// 			"input1" "@mixer.output_volume"
// 			"input2" "@volume_apply_falloff.output"	
// 		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distance"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"	
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distance.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_rear_stereo_scale" "1.0"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_test_convar.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "max"

			"left_front"   "0.0"	
			"right_front"  "0.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "0.0"
			"right_rear"   "0.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}	

	"p2_update_dialog_spatial_cave"
	{
		///////////////////////
        //  stopping previous lines
		"stop_entries"
		{
			"execute_once" "true"
			"operator" "sys_stop_entries"
			"match_channel" "true"
			"match_entity" "true"	
			"input_max_entries" "0" // doesn't include new one
		}

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			"source"   "entity"
//			"source"   "emitter"
		}
		"position_array"
		{
			"operator" "util_pos_vec8"
				
			"input_entry_count" "1"
			"input_index" "0"	
			"input_position_0" "@source_info.output_position"

		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@position_array.output_position"
		}

// 		"occlusion"
// 		{
// 			"operator" "calc_occlusion"
// 			"input_position" "@position_array.output_position"
// // 			"input_scalar" "0.5"
// // 			"input_trace_interval" "0.25"
// 		}

// 		// ramp distance to affect occlusion
// 		"remap_distance_occlusion"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "1000.0"
// 			"input_max" "1500.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"distance_occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@remap_distance_occlusion"
// 		}
// 		"occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@occlusion.output"
// 		}



		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "caveVO"
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}

		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		////////////////////////
		// tell the mixer we're active
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "90"
		}

		/////////////////////
		// VOLUME
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}

			
		// NOTE: distance has precalculated minimum distance of the ss players			
		// ramp distance to affect occlusion
// 		"remap_distance_falloff"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "2500.0"
// 			"input_max" "3000.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"remap_distance_falloff_invert"
// 		{
// 			"operator" "math_float"
// 			"apply"	"sub"
// 			"input1" "1"
// 			"input2" "@remap_distance_falloff.output"
// 		}
		
		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@source_info.output_volume"
//			"input2" "@occlusion.output"
			"input2" "1"
		}
		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_occlusion.output"
			"input2" "@volume_falloff.output"
		}
// 		"volume_apply_distance_falloff"
// 		{
// 			"operator" "math_float"
// 			"apply"	"mult"
// 			"input1" "@volume_apply_falloff.output"
// 			"input2" "@remap_distance_falloff_invert.output"
// 		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
// 		"volume_apply_distance_occlusion"
// 		{
// 			"operator" "math_float"
// 			"apply" "mult"	
// 			"input1" "@mixer.output_volume"
// 			"input2" "@volume_apply_falloff.output"	
// 		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distance"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"	
		}
 		"dsp_min"
		{
			"operator" "math_float"
			"apply" "max"	
			"input1" "0.4"
			"input2" "@dsp_apply_distance.output"	
		}
 		"dsp_max"
		{
			"operator" "math_float"
			"apply" "min"	
			"input1" "0.6"
			"input2" "@dsp_min.output"	
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_max.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "60"
			"input_rear_stereo_scale" "1.0"
			"input_distance"  "@source_distance.output"
			"input_position"  "@position_array.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_test_convar.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "max"

			"left_front"   "0.0"	
			"right_front"  "0.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "0.0"
			"right_rear"   "0.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}

		"speakers_multi_origin"
		{
			"operator"    "iterate_merge_speakers"

			"input_max_iterations" "@position_array.output_max_index"
            "iterate_operator" "position_array"
			"input" "@speakers_limit.output"

		}

		// connecting output after operator has been created
		"position_array"
		{
			"input_index" "@speakers_multi_origin.output_index"	
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_multi_origin.output"
			"output" "speakers"
		}
	}	

	"p2_update_dialog_spatial_cores"
	{
		"import_stack" "update_dialog_spatial"
		"mixer"
		{
			"mixgroup" "coreVO"
		}
		"speakers_spatialize"
		{
				"input_radius"  "200"
		}
	}

	"p2_update_dialog_spatial_wheatley"
	{
		///////////////////////
        //  stopping previous lines
		"stop_entries"
		{
			"execute_once" "true"
			"operator" "sys_stop_entries"
			"match_channel" "true"
			"match_entity" "true"	
			"input_max_entries" "0" // doesn't include new one
		}

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			"source"   "entity"
//			"source"   "emitter"
		}

        // NOTE: uses player data, ie: SS, returns minimum distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"
//			"input_trace_interval" "0.05"
//			"input_scalar" "0.7"
		}

// 		"print_occlusion"
// 		{
// 			"operator" "util_print_float"
// 			"input" "@occlusion.output"
// 		}
// 		// ramp distance to affect occlusion
// 		"remap_distance_occlusion"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "1000.0"
// 			"input_max" "1500.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"distance_occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@remap_distance_occlusion"
// 		}
// 		"occlusion_invert"
// 		{
// 			"operator" "math_float"
// 			"apply" "sub"	
// 			"input1" "1.0"
// 			"input2" "@occlusion.output"
// 		}



		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "wheatleyVO"
		}

		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}

		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		////////////////////////
		// tell the mixer we're active
		"output_mixlayer_trigger"
		{
			"execute_once" "1"
			"operator" "sys_output"
			"input_float" "1"
			"output" "mixlayer_trigger"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}

			
		// NOTE: distance has precalculated minimum distance of the ss players			
		// ramp distance to affect occlusion
// 		"remap_distance_falloff"
// 		{
// 			"operator" "math_remap_float"
// 			"input" "@source_distance.output"
// 			"input_min" "2500.0"
// 			"input_max" "3000.0"
// 			"input_map_min" "0.0"
// 			"input_map_max" "1.0"
// 			"default_to_max" "false"	
// 		}
// 		"remap_distance_falloff_invert"
// 		{
// 			"operator" "math_float"
// 			"apply"	"sub"
// 			"input1" "1"
// 			"input2" "@remap_distance_falloff.output"
// 		}
		"volume_test_distance"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@source_distance.output"
			"input2" "80"
		}
		"volume_defeat_occlusion"
		{
			"operator" "math_float"
			"apply" "max"	
			"input1" "@volume_test_distance.output"
			"input2" "@occlusion.output"	
		}
		
		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@source_info.output_volume"
			"input2" "@volume_defeat_occlusion.output"
//			"input2" "1"
		}
		"remap_distance_falloff"
		{
			"operator" "math_remap_float"
			"input" "@source_distance.output"
			"input_min" "400"
			"input_max" "600"
			"input_map_min" "1.0"
			"input_map_max" "1.3"
			"default_to_max" "false"	
		}
		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_occlusion.output"
			"input2" "@volume_falloff.output"
		}
		"volume_apply_distance_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_falloff.output"
			"input2" "@remap_distance_falloff.output"
		}
		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_distance_falloff.output"	
		}
// 		"volume_apply_distance_occlusion"
// 		{
// 			"operator" "math_float"
// 			"apply" "mult"	
// 			"input1" "@mixer.output_volume"
// 			"input2" "@volume_apply_falloff.output"	
// 		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distance"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"	
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distance.output"
			"output" "dsp"
		}

		/////////////////////
		// SPEAKERS
			
		"radius_get_sp_a1_intro1"
		{
//			"execute_once" "true"
//			"input_execute" "1.0" //enable map checking here
			"operator" "get_map_name"
			"map_name" "sp_a1_intro1" //your map name here
		}	
		"radius_invert_test"
		{
			"operator" "math_float"
			"apply" "less_than"	
			"input1" "@radius_get_sp_a1_intro1.output"
			"input2" "1.0"
		}

		"radius_remap_map_test1"
		{
			"operator" "math_remap_float"
			"input" "@radius_invert_test.output"
			"input_min" "0"
			"input_max" "1"
			"input_map_min" "600.0"
			"input_map_max" "600.0"
			"default_to_max" "false"	
		}
		// NOTE: uses player data, ie: SS, calculates all players and merges them
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "@radius_remap_map_test1.output"
			"input_rear_stereo_scale" "1.0"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_apply_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_test_convar.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "max"

			"left_front"   "0.0"	
			"right_front"  "0.0"	
			"center"       "0.0"	
			"lfe"          "0.0"	
			"left_rear"    "0.0"
			"right_rear"   "0.0"	
			
			"input2"	   "@speakers_apply_volume.output"
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}
	

////////////////////////////////////////////////////////////////////////////////////////////
//
// SPECIALTY STACKS
//
////////////////////////////////////////////////////////////////////////////////////////////

	"update_facing"
	{

		//////////////////////
		// POSITION
		"source_info"
		{
			"operator" "get_source_info"
			// "source"   "entity"
			"source"   "emitter"
		}

		// NOTE: uses player data, ie: SS, returns nearest distance
		"source_distance"
		{
			"operator" "calc_source_distance"
			"input_position"   "@source_info.output_position"
		}

		////////////////////
		// calc
		"mixer"
		{
			"operator" "get_soundmixer"
			"mixgroup" "TEST"
		}

		// NOTE: uses player data, ie: SS, least occluded player
		"occlusion"
		{
			"operator" "calc_occlusion"
			"input_position" "@source_info.output_position"
		}

		// NOTE: uses player data, ie: blended origin for SS players
		"facing"
		{
			"operator" "calc_angles_facing"
			// "input_angles" "@source_info.output_angles"
			"input_angles[0]" "0"
			"input_angles[1]" "0"
			"input_angles[2]" "0"
		}

		"facing_output"
		{
			"operator" "sys_output"
			"input_float" "@facing.output"
			"output" "facing"
		}
		"snd_gain_convar"
		{
			"operator" "get_convar"
			"convar" "snd_gain"
		}

		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}

		//////////////////////
		// LEVEL
		"level_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_level"
			"input2" "@source_info.output_level"
		}

		/////////////////////
		// VOLUME
		"volume_falloff"
		{
			"operator" "calc_falloff"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"volume_apply_falloff"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@source_info.output_volume"
			"input2" "@volume_falloff.output"
		}

		"volume_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_volume"
			"input2" "@volume_apply_falloff.output"	
		}
		"volume_apply_snd_gain_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@snd_gain_convar.output"
			"input2" "@volume_apply_mixer.output"	
		}
		"volume_apply_test_convar"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "1.0"
			"input2" "@volume_apply_snd_gain_convar.output"	
		}

		"volume_apply_facing"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@facing.output"
			"input2" "@volume_apply_test_convar.output"	
		}

		"volume_apply_occlusion"
		{
			"operator" "math_float"
			"apply"	"mult"
			"input1" "@volume_apply_facing.output"
			"input2" "@occlusion.output"
		}

		///////////////////
		// PITCH
		"pitch_output"
		{
			"operator" "sys_output"
			"output"   "pitch"
			"input_float" "@source_info.output_pitch"	
		}

		///////////////////
		// DSP
		"dsp_emitter"
		{
			"operator" "math_float"
			"apply"	      "set"
			"input1" "1.0"	
		}
		"dsp_apply_mixer"
		{
			"operator" "math_float"
			"apply" "mult"	
			"input1" "@mixer.output_dsp"
			"input2" "@dsp_emitter.output"	
		}
		"dsp_distantDSP"
		{
			"operator" "calc_distant_dsp"
			"input_distance"  "@source_distance.output"
			"input_level"	  "@level_apply_mixer.output"
		}
		"dsp_apply_distant"
		{
			"operator" "math_float"
			"apply"	      "mult"
			"input1" "@dsp_distantDSP.output"
			"input2" "@dsp_apply_mixer.output"			
		}
		"dsp_output"
		{
			"operator" "sys_output"
			"input_float" "@dsp_apply_distant.output"
			"output" "speakers"
		}
		/////////////////////
		// SPEAKERS

		// NOTE: uses player data, ie: SS
        // SS COULD BE SELF-CONTAINED? 
		"speakers_spatialize"
		{
			"operator" "calc_spatialize_speakers"
			"input_radius"  "300"
			"input_distance"  "@source_distance.output"
			"input_position"  "@source_info.output_position"
		}
	
		"speakers_volume"
		{
			"operator"     "math_speakers"
			"apply"	       "mult"
			"input1"       "@speakers_spatialize.output"
			"input2[*]"	   "@volume_apply_occlusion.output"
			// "input2[*]"	   "@facing.output"
		}

		"speakers_limit"
		{
			"operator"      "math_speakers"
			"apply"	       "mult"
			"left_front"   "1.0"	
			"right_front"  "1.0"	
			"center"       "1.0"	
			"lfe"          "1.0"	
			"left_rear"    "1.0"
			"right_rear"   "1.0"	
			
			"input2" "@speakers_volume.output"
		
		}

		"speakers_output"
		{
			"operator" "sys_output"
			"input_speakers" "@speakers_limit.output"
			"output" "speakers"
		}
	}	

}

"stop_stacks"
{
	"stop_test"
	{
		"play_entry"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"1"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}	

	}
	"stop_default"
	{
		"snd_op_test_convar"
		{
			"operator" "get_convar"
			"convar" "snd_op_test_convar"
		}
	}

	"stop_and_play"
	{
		"play_entry"
		{
			"operator" "sys_start_entry"
			"execute_once" "true"
			"input_execute"	"1"
			"input_start" "1"
			"entry_name" "Default.Null" //Replace with the sound you want to play.
		}
	}

	"P2_stop_child_and_parent"
	{
		
		"stop_child"
		{
			"operator" "sys_stop_entries"
			"input_max_entries" "0.000000" //A sound will not stop itself from playing.
			"match_substring" "false"	
			"match_entry" "Default.Null" //Replace with the sound you want to stop.
			"match_entity" "true"
		}
	}


////////////////////////////////////////////////////////////////////////////////////////////
//
// dialog stop stacks
//
////////////////////////////////////////////////////////////////////////////////////////////

	"P2_glados_stop" // default stop stack for glados v.o.
	{
		"set_mixlayer_vol_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "announcerVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_cave"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "caveVO"
			"field" "volume"
			"input" "1.0"
		}
	}
	"P2_glados_stop_mute" // default stop stack for glados v.o.
	{
		"set_mixlayer_mute_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "mute"
			"input" "0.0"
		}
		"set_mixlayer_mute_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "announcerVO"
			"field" "mute"
			"input" "0.0"
		}
		"set_mixlayer_mute_cave"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "gladosVOLayer"
			"mixgroup" "caveVO"
			"field" "mute"
			"input" "0.0"
		}
	}
	"P2_wheatley_stop" // default stop stack for wheatley v.o.
	{
		"set_mixlayer_vol_glados"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "wheatleyVOLayer"
			"mixgroup" "gladosVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_announcer"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "wheatleyVOLayer"
			"mixgroup" "announcerVO"
			"field" "volume"
			"input" "1.0"
		}
	}
	"P2_announcer_stop" // default stop stack for announcer v.o.
	{
		"set_mixlayer_vol_glados"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "announcerVOLayer"
			"mixgroup" "gladosVO"
			"field" "volume"
			"input" "1.0"
		}
		"set_mixlayer_vol_wheatley"
		{
			"operator" "sys_mixlayer"
			"mixlayer" "announcerVOLayer"
			"mixgroup" "wheatleyVO"
			"field" "volume"
			"input" "1.0"
		}
	}
}
